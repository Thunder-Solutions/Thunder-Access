{"version":3,"file":"addAccessibilityRules.min.mjs","sources":["../libs/utilities.js","../libs/domState.js","../node_modules/specificity/dist/specificity.mjs","../libs/getUtilities.js","../libs/updateAll.js","../libs/updateAttributes.js","../libs/updateKeyboardInteractivity.js","../libs/updateMouseInteractivity.js","../libs/updateScreenReaderText.js","../libs/watchAttributesForChanges.js","../libs/addAccessibilityRules.js"],"sourcesContent":["// error logging\r\nconst errorPrefix = 'Problem evaluating accessibility'\r\nexport const logError = err => {\r\n  if (typeof jest === 'undefined') console.error(`${errorPrefix}: ${err}`)\r\n}\r\nexport const throwError = err => { throw new Error(`${errorPrefix}: ${err}`) }\r\n\r\n// validate selectors without breaking\r\nexport const checkSelectorValidity = selector => {\r\n  const isString = typeof selector === 'string'\r\n  let isValidSelector = true\r\n  try { getRoot().querySelector(selector) }\r\n  catch(err) { isValidSelector = false }\r\n  const isStringAndValid = isString && isValidSelector\r\n  if (!isStringAndValid) logError(`${selector} is not a valid selector.`)\r\n  return isStringAndValid\r\n}\r\n\r\n// get all elements that can be accessed naturally with `tab`\r\nexport const getTabbableElements = () => {\r\n  const tabbableSelector = `\r\n    a:not([disabled]):not([tabindex=\"-1\"]),\r\n    button:not([disabled]):not([tabindex=\"-1\"]),\r\n    input:not([disabled]):not([tabindex=\"-1\"]),\r\n    [tabindex]:not([disabled]):not([tabindex=\"-1\"])\r\n  `\r\n  return [...getRoot().querySelectorAll(tabbableSelector)]\r\n    .filter(el => !el.closest('[aria-hidden=\"true\"]') || !!el.offsetParent)\r\n}\r\n\r\nexport const Events = {\r\n  \r\n  _listeners: {\r\n    addQueue: [],\r\n    removeQueue: [],\r\n    current: new Map(),\r\n  },\r\n\r\n  add(selector, event, listener) {\r\n    this._listeners.addQueue.push({selector, event, listener})\r\n  },\r\n\r\n  removeAll(selector) {\r\n    this._listeners.removeQueue.push(selector)\r\n  },\r\n\r\n  update() {\r\n    const listeners = this._listeners\r\n    listeners.addQueue.forEach(({selector, event, listener}) => {\r\n      const currentListeners = listeners.current.get(selector) || []\r\n      const inCurrent = currentListeners.find(a =>\r\n        a.event === event && String(a.listener) === String(listener))\r\n      if (inCurrent) return\r\n\r\n      const els = [...document.querySelectorAll(selector)]\r\n      els.forEach(el => {\r\n        el.addEventListener(event, listener)\r\n        currentListeners.push({event, listener})\r\n        listeners.current.set(selector, currentListeners)\r\n      })\r\n    })\r\n    listeners.removeQueue.forEach(selector => {\r\n      const currentListeners = listeners.current.get(selector)\r\n      if (!currentListeners) return\r\n      let newListeners = []\r\n      \r\n      currentListeners.forEach(({event, listener}) => {\r\n        const currentAddQueue = listeners.addQueue.filter(a => a.selector === selector)\r\n        const inAddQueue = currentAddQueue.find(a =>\r\n          a.event === event && String(a.listener) === String(listener))\r\n        if (inAddQueue) return newListeners.push({event, listener})\r\n\r\n        const els = [...document.querySelectorAll(selector)]\r\n        els.forEach(el => el.removeEventListener(event, listener))\r\n      })\r\n      listeners.current.set(selector, newListeners)\r\n    })\r\n    \r\n    listeners.removeQueue = []\r\n    listeners.addQueue = []\r\n  },\r\n}\r\n\r\n// get the root element\r\nexport const rootObj = { element: null }\r\nexport const getRoot = () => rootObj.element || typeof document !== 'undefined' && document.body\r\n  || throwError('Could not find the root element.')\r\n\r\nexport const swapAndPop = (arr, idx) => {\r\n  const lastIdx = arr.length - 1\r\n  const last = arr[lastIdx]\r\n  const current = arr[idx]\r\n  arr[lastIdx] = current\r\n  arr[idx] = last\r\n  return arr.pop()\r\n}","const domState = new Map()\n\nexport const getElementState = element => {\n  if (!domState.get(element)) {\n    domState.set(element, {\n      inlineAttributes: Array.from(element.attributes),\n      attributeObserver: null,\n      screenReaderElement: null,\n      methods: {},\n      rules: {},\n    })\n  }\n  return domState.get(element)\n}\n\nexport const updateElementState = (element, callback) => {\n  const elementState = getElementState(element)\n  domState.set(element, callback(elementState))\n}\n\nexport default domState\n","// Calculate the specificity for a selector by dividing it into simple selectors and counting them\nvar calculate = function(input) {\n\tvar selectors,\n\t\tselector,\n\t\ti,\n\t\tlen,\n\t\tresults = [];\n\n\t// Separate input by commas\n\tselectors = input.split(',');\n\n\tfor (i = 0, len = selectors.length; i < len; i += 1) {\n\t\tselector = selectors[i];\n\t\tif (selector.length > 0) {\n\t\t\tresults.push(calculateSingle(selector));\n\t\t}\n\t}\n\n\treturn results;\n};\n\n/**\n * Calculates the specificity of CSS selectors\n * http://www.w3.org/TR/css3-selectors/#specificity\n *\n * Returns an object with the following properties:\n *  - selector: the input\n *  - specificity: e.g. 0,1,0,0\n *  - parts: array with details about each part of the selector that counts towards the specificity\n *  - specificityArray: e.g. [0, 1, 0, 0]\n */\nvar calculateSingle = function(input) {\n\tvar selector = input,\n\t\tfindMatch,\n\t\ttypeCount = {\n\t\t\t'a': 0,\n\t\t\t'b': 0,\n\t\t\t'c': 0\n\t\t},\n\t\tparts = [],\n\t\t// The following regular expressions assume that selectors matching the preceding regular expressions have been removed\n\t\tattributeRegex = /(\\[[^\\]]+\\])/g,\n\t\tidRegex = /(#[^\\#\\s\\+>~\\.\\[:\\)]+)/g,\n\t\tclassRegex = /(\\.[^\\s\\+>~\\.\\[:\\)]+)/g,\n\t\tpseudoElementRegex = /(::[^\\s\\+>~\\.\\[:]+|:first-line|:first-letter|:before|:after)/gi,\n\t\t// A regex for pseudo classes with brackets - :nth-child(), :nth-last-child(), :nth-of-type(), :nth-last-type(), :lang()\n\t\t// The negation psuedo class (:not) is filtered out because specificity is calculated on its argument\n\t\t// :global and :local are filtered out - they look like psuedo classes but are an identifier for CSS Modules\n\t\tpseudoClassWithBracketsRegex = /(:(?!not|global|local)[\\w-]+\\([^\\)]*\\))/gi,\n\t\t// A regex for other pseudo classes, which don't have brackets\n\t\tpseudoClassRegex = /(:(?!not|global|local)[^\\s\\+>~\\.\\[:]+)/g,\n\t\telementRegex = /([^\\s\\+>~\\.\\[:]+)/g;\n\n\t// Find matches for a regular expression in a string and push their details to parts\n\t// Type is \"a\" for IDs, \"b\" for classes, attributes and pseudo-classes and \"c\" for elements and pseudo-elements\n\tfindMatch = function(regex, type) {\n\t\tvar matches, i, len, match, index, length;\n\t\tif (regex.test(selector)) {\n\t\t\tmatches = selector.match(regex);\n\t\t\tfor (i = 0, len = matches.length; i < len; i += 1) {\n\t\t\t\ttypeCount[type] += 1;\n\t\t\t\tmatch = matches[i];\n\t\t\t\tindex = selector.indexOf(match);\n\t\t\t\tlength = match.length;\n\t\t\t\tparts.push({\n\t\t\t\t\tselector: input.substr(index, length),\n\t\t\t\t\ttype: type,\n\t\t\t\t\tindex: index,\n\t\t\t\t\tlength: length\n\t\t\t\t});\n\t\t\t\t// Replace this simple selector with whitespace so it won't be counted in further simple selectors\n\t\t\t\tselector = selector.replace(match, Array(length + 1).join(' '));\n\t\t\t}\n\t\t}\n\t};\n\n\t// Replace escaped characters with plain text, using the \"A\" character\n\t// https://www.w3.org/TR/CSS21/syndata.html#characters\n\t(function() {\n\t\tvar replaceWithPlainText = function(regex) {\n\t\t\t\tvar matches, i, len, match;\n\t\t\t\tif (regex.test(selector)) {\n\t\t\t\t\tmatches = selector.match(regex);\n\t\t\t\t\tfor (i = 0, len = matches.length; i < len; i += 1) {\n\t\t\t\t\t\tmatch = matches[i];\n\t\t\t\t\t\tselector = selector.replace(match, Array(match.length + 1).join('A'));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t// Matches a backslash followed by six hexadecimal digits followed by an optional single whitespace character\n\t\t\tescapeHexadecimalRegex = /\\\\[0-9A-Fa-f]{6}\\s?/g,\n\t\t\t// Matches a backslash followed by fewer than six hexadecimal digits followed by a mandatory single whitespace character\n\t\t\tescapeHexadecimalRegex2 = /\\\\[0-9A-Fa-f]{1,5}\\s/g,\n\t\t\t// Matches a backslash followed by any character\n\t\t\tescapeSpecialCharacter = /\\\\./g;\n\n\t\treplaceWithPlainText(escapeHexadecimalRegex);\n\t\treplaceWithPlainText(escapeHexadecimalRegex2);\n\t\treplaceWithPlainText(escapeSpecialCharacter);\n\t}());\n\n\t// Remove anything after a left brace in case a user has pasted in a rule, not just a selector\n\t(function() {\n\t\tvar regex = /{[^]*/gm,\n\t\t\tmatches, i, len, match;\n\t\tif (regex.test(selector)) {\n\t\t\tmatches = selector.match(regex);\n\t\t\tfor (i = 0, len = matches.length; i < len; i += 1) {\n\t\t\t\tmatch = matches[i];\n\t\t\t\tselector = selector.replace(match, Array(match.length + 1).join(' '));\n\t\t\t}\n\t\t}\n\t}());\n\n\t// Add attribute selectors to parts collection (type b)\n\tfindMatch(attributeRegex, 'b');\n\n\t// Add ID selectors to parts collection (type a)\n\tfindMatch(idRegex, 'a');\n\n\t// Add class selectors to parts collection (type b)\n\tfindMatch(classRegex, 'b');\n\n\t// Add pseudo-element selectors to parts collection (type c)\n\tfindMatch(pseudoElementRegex, 'c');\n\n\t// Add pseudo-class selectors to parts collection (type b)\n\tfindMatch(pseudoClassWithBracketsRegex, 'b');\n\tfindMatch(pseudoClassRegex, 'b');\n\n\t// Remove universal selector and separator characters\n\tselector = selector.replace(/[\\*\\s\\+>~]/g, ' ');\n\n\t// Remove any stray dots or hashes which aren't attached to words\n\t// These may be present if the user is live-editing this selector\n\tselector = selector.replace(/[#\\.]/g, ' ');\n\n\t// Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument\n \t// Remove non-standard :local and :global CSS Module identifiers because they do not effect the specificity\n\tselector = selector.replace(/:not/g, '    ');\n\tselector = selector.replace(/:local/g, '      ');\n\tselector = selector.replace(/:global/g, '       ');\n\tselector = selector.replace(/[\\(\\)]/g, ' ');\n\n\t// The only things left should be element selectors (type c)\n\tfindMatch(elementRegex, 'c');\n\n\t// Order the parts in the order they appear in the original selector\n\t// This is neater for external apps to deal with\n\tparts.sort(function(a, b) {\n\t\treturn a.index - b.index;\n\t});\n\n\treturn {\n\t\tselector: input,\n\t\tspecificity: '0,' + typeCount.a.toString() + ',' + typeCount.b.toString() + ',' + typeCount.c.toString(),\n\t\tspecificityArray: [0, typeCount.a, typeCount.b, typeCount.c],\n\t\tparts: parts\n\t};\n};\n\n/**\n * Compares two CSS selectors for specificity\n * Alternatively you can replace one of the CSS selectors with a specificity array\n *\n *  - it returns -1 if a has a lower specificity than b\n *  - it returns 1 if a has a higher specificity than b\n *  - it returns 0 if a has the same specificity than b\n */\nvar compare = function(a, b) {\n\tvar aSpecificity,\n\t\tbSpecificity,\n\t\ti;\n\n\tif (typeof a ==='string') {\n\t\tif (a.indexOf(',') !== -1) {\n\t\t\tthrow 'Invalid CSS selector';\n\t\t} else {\n\t\t\taSpecificity = calculateSingle(a)['specificityArray'];\n\t\t}\n\t} else if (Array.isArray(a)) {\n\t\tif (a.filter(function(e) { return (typeof e === 'number'); }).length !== 4) {\n\t\t\tthrow 'Invalid specificity array';\n\t\t} else {\n\t\t\taSpecificity = a;\n\t\t}\n\t} else {\n\t\tthrow 'Invalid CSS selector or specificity array';\n\t}\n\n\tif (typeof b ==='string') {\n\t\tif (b.indexOf(',') !== -1) {\n\t\t\tthrow 'Invalid CSS selector';\n\t\t} else {\n\t\t\tbSpecificity = calculateSingle(b)['specificityArray'];\n\t\t}\n\t} else if (Array.isArray(b)) {\n\t\tif (b.filter(function(e) { return (typeof e === 'number'); }).length !== 4) {\n\t\t\tthrow 'Invalid specificity array';\n\t\t} else {\n\t\t\tbSpecificity = b;\n\t\t}\n\t} else {\n\t\tthrow 'Invalid CSS selector or specificity array';\n\t}\n\n\tfor (i = 0; i < 4; i += 1) {\n\t\tif (aSpecificity[i] < bSpecificity[i]) {\n\t\t\treturn -1;\n\t\t} else if (aSpecificity[i] > bSpecificity[i]) {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n};\n\nexport { calculate, compare };\n","import { checkSelectorValidity, getTabbableElements, getRoot, logError } from './utilities.js'\r\n\r\n// focus utility with common options\r\nconst focus = option => {\r\n\r\n  // handle an element if it was passed\r\n  if (option instanceof HTMLElement) return option.focus()\r\n\r\n  // make sure the option is a string if not an element\r\n  if (option.constructor !== String) return logError('the `focus()` method expects either an element or a string.')\r\n\r\n  // get all tabbable elements for reference\r\n  const tabbableElements = getTabbableElements()\r\n  const currentIndex = tabbableElements\r\n    .findIndex(e => e === document.activeElement)\r\n  const finalIndex = tabbableElements.length - 1\r\n\r\n  // handle keywords\r\n  switch(option) {\r\n    case 'next':\r\n      const nextIndex =\r\n        currentIndex < finalIndex ? currentIndex + 1 : 0\r\n      tabbableElements[nextIndex].focus()\r\n      break\r\n    case 'previous':\r\n      const prevIndex =\r\n        currentIndex > 0 ? currentIndex - 1 : finalIndex\r\n      tabbableElements[prevIndex].focus()\r\n      break\r\n    case 'off':\r\n      event.currentTarget.blur()\r\n      break\r\n  }\r\n  if (['next', 'previous', 'off'].includes(option)) return\r\n\r\n  // handle selectors\r\n  if (checkSelectorValidity(option))\r\n    getRoot().querySelector(option).focus()\r\n}\r\n\r\n// expand utility using aria-expanded and aria-hidden\r\nconst toggleExpanded = (parentSelector, childSelector, override) => {\r\n  const root = getRoot()\r\n  const parentItem = root.querySelector(parentSelector)\r\n  const childItem = root.querySelector(childSelector)\r\n  const expandValue =\r\n        override !== undefined ?\r\n        override :\r\n        !!parentItem && parentItem.getAttribute('aria-expanded') === 'true'\r\n  if (parentItem) parentItem.setAttribute('aria-expanded', !expandValue)\r\n  else console.error('Error expanding the element: No parent item matched the selector.')\r\n  if (childItem) childItem.setAttribute('aria-hidden', expandValue)\r\n  else console.error('Error expanding the element: No child item matched the selector.')\r\n}\r\n\r\n// utility for the user to get the expanded state of a popup item\r\nconst getExpanded = item => {\r\n  const element =\r\n    typeof item === 'string' ?\r\n    checkSelectorValidity(item) &&\r\n    root.querySelector(item) :\r\n    item\r\n  return element.getAttribute('aria-expanded') === 'true'\r\n}\r\n\r\n// use this for tracking focus traps, add/restore focusability\r\nconst focusTrap = {\r\n  externalElements: new Map(),\r\n  parentElement: null,\r\n  isTrapped: false,\r\n}\r\n\r\n// focus trap utility\r\nconst toggleFocusTrap = (item, override) => {\r\n  focusTrap.parentElement =\r\n    typeof item === 'string' ?\r\n    checkSelectorValidity(item) &&\r\n    getRoot().querySelector(item) :\r\n    item\r\n  \r\n  // filter out all the tabbable elements within the givin scope\r\n  const tabbableElements = getTabbableElements()\r\n  const externalElements =\r\n    !!focusTrap.parentElement\r\n    ? tabbableElements.filter(el => !focusTrap.parentElement.contains(el)) \r\n    : console.error('Error applying focus trap: No element matched the selector.') || []\r\n  \r\n  // restore previously saved tabindexes to their original values\r\n  const exEls = focusTrap.externalElements\r\n  exEls.forEach((tabindex, el) => {\r\n    if (tabindex !== null) el.setAttribute('tabindex', tabindex)\r\n    else el.removeAttribute('tabindex')\r\n    exEls.delete(el)\r\n  })\r\n  \r\n  // boolean for whether to trap focus or not\r\n  const trapFocus =\r\n    override !== undefined ?\r\n    override :\r\n    !focusTrap.isTrapped\r\n  \r\n  // set all elements outside the given scope to tabindex -1\r\n  // (store current tabindexes so they can be restored later)\r\n  if (trapFocus) externalElements.forEach(el => {\r\n    focusTrap.externalElements.set(el, el.getAttribute('tabindex'))\r\n    el.setAttribute('tabindex', '-1')\r\n  })\r\n  focusTrap.isTrapped = trapFocus\r\n}\r\n\r\n// return all utility methods using the passed element as the default\r\nexport default element => ({\r\n  focus,\r\n  toggleExpanded,\r\n  getExpanded: (item = element) => getExpanded(item),\r\n  toggleFocusTrap: (item = element) => toggleFocusTrap(item),\r\n})\r\n","import { Events } from './utilities.js'\r\nimport updateAttributes from './updateAttributes.js'\r\nimport updateKeyboardInteractivity from './updateKeyboardInteractivity.js'\r\nimport updateMouseInteractivity from './updateMouseInteractivity.js'\r\nimport updateScreenReaderText from './updateScreenReaderText.js'\r\n\r\n// jest.mock will not work, so this object makes\r\n// this file easier to test with spyOn instead.\r\nexport const updateFns = {\r\n  updateAttributes,\r\n  updateKeyboardInteractivity,\r\n  updateMouseInteractivity,\r\n  updateScreenReaderText,\r\n}\r\n\r\nexport default element => {\r\n  updateFns.updateAttributes(element)\r\n  updateFns.updateKeyboardInteractivity(element)\r\n  updateFns.updateMouseInteractivity(element)\r\n  updateFns.updateScreenReaderText(element)\r\n  Events.update()\r\n}","import { getElementState } from './domState.js'\nimport { logError } from './utilities.js'\n\nexport default element => {\n\n  const {inlineAttributes, rules} = getElementState(element)\n\n  // utility for setting attributes\n  const setAttr = (name, value) => {\n    const isSame = element.getAttribute(name) === String(value)\n    const isInline = !!inlineAttributes.find(a => a.name === name)\n    const blackList = [\n      'class',\n      'id',\n      'style',\n    ]\n\n    // disallow rules to assign black-listed attributes\n    if (blackList.includes(name) || name.startsWith('on'))\n      return logError(`Cannot assign black-listed attribute: \"${name}\"`)\n\n    // update the actual attribute in the DOM\n    if (!isInline && !isSame) element.setAttribute(name, value)\n  }\n\n  // apply the attributes as dictated by the rules\n  Object.keys(rules).forEach(selector => {\n    if (!element.matches(selector)) return\n    const {aria, attr} = rules[selector]\n\n    // add aria attributes\n    if (aria) Object.keys(aria).forEach(\n      attrName => setAttr(`aria-${attrName}`, aria[attrName]))\n    \n    // add all other attributes\n    if (attr) Object.keys(attr).forEach(\n      attrName => setAttr(attrName, attr[attrName]))\n  })\n\n}\n","import { Events, logError } from './utilities.js'\r\nimport getUtilities from './getUtilities.js'\r\nimport { getElementState } from './domState.js'\r\n\r\nexport default element => {\r\n  const {rules, methods} = getElementState(element)\r\n\r\n  Object.keys(rules).forEach(selector => {\r\n    Events.removeAll(selector)\r\n\r\n    if (!element.matches(selector)) return\r\n    const {keyboard, keyboardEvent} = rules[selector]\r\n    if (!keyboard) return\r\n\r\n    // evaluate the keyboard configuration\r\n    const utils = getUtilities(element)\r\n    const keyList = Object.keys(keyboard)\r\n    const validKeyEvents = ['keydown', 'keypress', 'keyup']\r\n    const isValidKeyEvent =\r\n      keyboardEvent\r\n      && validKeyEvents.includes(keyboardEvent)\r\n    const keyEvent = isValidKeyEvent ? keyboardEvent : 'keydown'\r\n    if (keyboardEvent ? !isValidKeyEvent : false)\r\n      logError(`\"${keyboardEvent}\" is not a valid keyboard event; using \"keydown\" instead.`)\r\n\r\n    Events.add(selector, keyEvent, event => {\r\n      if (!keyList.includes(event.key)) return\r\n      keyboard[event.key].forEach(\r\n        methodKey => methods[methodKey](utils, event))\r\n    })\r\n  })\r\n}\r\n","import { Events } from './utilities.js'\r\nimport getUtilities from './getUtilities.js'\r\nimport { getElementState } from './domState.js'\r\n\r\nexport default (element) => {\r\n  const {rules, methods} = getElementState(element)\r\n\r\n  Object.keys(rules).forEach(selector => {\r\n    Events.removeAll(selector)\r\n\r\n    if (!element.matches(selector)) return\r\n    const {mouse} = rules[selector]\r\n    if (!mouse) return\r\n\r\n    // evaluate the mouse configuration\r\n    const utils = getUtilities(element)\r\n    const {click, enter, leave} = mouse\r\n\r\n    const addMouseEvent = (methodKeys, eventStr) => {\r\n      Events.add(selector, eventStr, event => {\r\n        methodKeys.forEach(methodKey => methods[methodKey](utils, event))\r\n      })\r\n    }\r\n\r\n    if (click) addMouseEvent(click, 'click')\r\n    if (enter) addMouseEvent(enter, 'mouseenter')\r\n    if (leave) addMouseEvent(leave, 'mouseleave')\r\n  })\r\n}\r\n","import { getElementState, updateElementState } from './domState.js'\r\n\r\nexport default element => {\r\n\r\n  const elementState = getElementState(element)\r\n  const { rules, screenReaderElement } = elementState\r\n  const selectors = Object.keys(rules).reverse()\r\n  const ruleSelector = selectors.find(selector =>\r\n    element.matches(selector) && typeof rules[selector].screenReaderText === 'string')\r\n  if (!ruleSelector) return screenReaderElement && screenReaderElement.remove()\r\n  const {screenReaderText} = rules[ruleSelector]\r\n\r\n  // this will initially create an element and set the style as needed\r\n  const createScreenReaderElement = () => {\r\n    const span = document.createElement('span')\r\n    span.style = 'position:absolute;z-index:-9999999;opacity:0;'\r\n    return span\r\n  }\r\n  \r\n  // store the screen reader element as part of the element state\r\n  updateElementState(element, elementState => {\r\n    elementState.screenReaderElement = \r\n      elementState.screenReaderElement || createScreenReaderElement()\r\n    return elementState\r\n  })\r\n\r\n  // apply text content and push to DOM\r\n  elementState.screenReaderElement.remove()\r\n  elementState.screenReaderElement.textContent = screenReaderText\r\n  element.insertBefore(elementState.screenReaderElement, element.firstChild)\r\n}\r\n","import { updateElementState, getElementState } from './domState.js'\r\nimport { swapAndPop } from './utilities.js'\r\nimport updateAll from './updateAll.js'\r\n\r\n// exporting functions as methods on an object so it's easier to test\r\nexport const observerUtils = {\r\n  updateAttrsInState(element, attrMutations) {\r\n    attrMutations.forEach(mutation => {\r\n      const modifiedAttr = mutation ? mutation.target.attributes[mutation.attributeName] : {}\r\n      updateElementState(element, elementState => {\r\n        const existingIdx = elementState.inlineAttributes.findIndex(a => a.name === modifiedAttr.name)\r\n        const idx = existingIdx !== -1 ? existingIdx : elementState.inlineAttributes.length\r\n        if (modifiedAttr) elementState.inlineAttributes[idx] = modifiedAttr\r\n        else swapAndPop(elementState.inlineAttributes, idx)\r\n        return elementState\r\n      })\r\n    })\r\n  },\r\n  \r\n  removeNonInlineAttrs(element) {\r\n    const elementState = getElementState(element)\r\n    const {inlineAttributes} = elementState\r\n    Array.from(element.attributes).forEach(({name}) => {\r\n      const isInline = !!inlineAttributes.find(a => a.name === name)\r\n      if (isInline) return\r\n      element.removeAttribute(name)\r\n    })\r\n  },\r\n  \r\n  updateChildElAttrs(element) {\r\n    element.querySelectorAll('*').forEach(el => {\r\n      const {attributeObserver} = getElementState(el)\r\n      if (attributeObserver) attributeObserver.disconnect()\r\n      this.removeNonInlineAttrs(el)\r\n      updateAll(el)\r\n      if (attributeObserver)\r\n        setTimeout(() => attributeObserver.observe(el, { attributes: true }), 0)\r\n    })\r\n  },\r\n  \r\n  setAttrChangeCallback(element) {\r\n    this.attrChangeCallback = (mutations, observer) => {\r\n  \r\n      // temporarily stop observing so attribute manipulations can occur safely\r\n      observer.disconnect()\r\n    \r\n      // update this element and all its children\r\n      const attrMutations = mutations.filter(\r\n        ({target, attributeName}) => target.attributes[attributeName])\r\n      this.updateAttrsInState(element, attrMutations)\r\n      this.removeNonInlineAttrs(element)\r\n      updateAll(element)\r\n      this.updateChildElAttrs(element)\r\n      \r\n      // make sure it does not start observing again until after all other scripts in the event loop finish\r\n      setTimeout(() => {\r\n        observer.observe(element, { attributes: true })\r\n      }, 0)\r\n    }\r\n  },\r\n\r\n  attrChangeCallback: null,\r\n}\r\n\r\nexport default element => {\r\n\r\n  // initialize the mutation observer\r\n  observerUtils.setAttrChangeCallback(element)\r\n  const MutationObserver = typeof MutationObserver !== 'undefined'\r\n    ? MutationObserver\r\n    : class { observe() {} }\r\n  const observer = new MutationObserver(observerUtils.attrChangeCallback)\r\n  observer.observe(element, { attributes: true })\r\n\r\n  // attach the observer to the element state\r\n  updateElementState(element, elementState => {\r\n    elementState.attributeObserver = observer\r\n    return elementState\r\n  })\r\n}\r\n\r\n","import { throwError, checkSelectorValidity, rootObj, getRoot } from './utilities.js'\r\nimport { updateElementState } from './domState.js'\r\nimport { compare } from 'specificity'\r\nimport updateAll from './updateAll.js'\r\nimport watchAttributesForChanges from './watchAttributesForChanges.js'\r\n\r\n// exporting functions as methods on an object so it's easier to test\r\nexport const ruleUtilities = {\r\n  setApplyRulesCallback(config) {\r\n\r\n    // order the rules by least specific selector to most specific selector\r\n    const selectors = Object.keys(config.rules).sort(compare)\r\n\r\n    this.applyRulesCallback = mutations => selectors.forEach(selector => {\r\n    \r\n      // don't reapply the rules of this selector if no matching elements were added\r\n      if (mutations) {\r\n        const {addedNodes} = mutations.find(mutation => mutation.addedNodes)\r\n        const anyMatches = [...addedNodes]\r\n          .some(node => node instanceof HTMLElement && node.matches(selector))\r\n        if (!anyMatches) return\r\n      }\r\n      \r\n      // validate the given selector\r\n      if (!checkSelectorValidity(selector)) return\r\n      \r\n      // apply the rule to all elements matching the selector\r\n      getRoot().querySelectorAll(selector).forEach(element => {\r\n        const { rules, methods } = config\r\n        const rule = rules && rules[selector] || {}\r\n\r\n        // add this element to the state internally, like a virtual DOM\r\n        updateElementState(element, elementState => {\r\n          elementState.rules[selector] = rule\r\n          elementState.methods = methods\r\n          return elementState\r\n        })\r\n\r\n        // update the DOM based on the state determined above\r\n        updateAll(element)\r\n\r\n        // keep the DOM updated when external changes are applied\r\n        watchAttributesForChanges(element)\r\n      })\r\n    })\r\n  },\r\n  applyRulesCallback: null,\r\n  observer: null,\r\n}\r\n\r\nexport default config => {\r\n\r\n  // early escape clauses in case of errors\r\n  const configType = !!config ? config.constructor.name : String(config)\r\n  if (!config || config.constructor !== Object)\r\n    throwError(`Expected Object, but got ${configType}`)\r\n  rootObj.element = config.root\r\n  const rules = config.rules || {}\r\n  const methods = config.methods || {}\r\n  if (rules.constructor !== Object || methods.constructor !== Object)\r\n    throwError('The `rules` and `methods` properties must be objects.')\r\n  \r\n  // main function to run initially and as a callback\r\n  ruleUtilities.setApplyRulesCallback(config)\r\n\r\n  // attach main function as a mutation observer to the root element\r\n  const MutationObserver = typeof MutationObserver !== 'undefined'\r\n    ? MutationObserver\r\n    : class { observe() {} }\r\n  ruleUtilities.observer = new MutationObserver(ruleUtilities.applyRulesCallback)\r\n  ruleUtilities.observer.observe(getRoot(), {\r\n    childList: true,\r\n    subtree: true,\r\n  })\r\n  \r\n  // initial run\r\n  ruleUtilities.applyRulesCallback()\r\n}\r\n"],"names":["logError","err","jest","console","error","throwError","Error","checkSelectorValidity","selector","isString","isValidSelector","getRoot","querySelector","isStringAndValid","getTabbableElements","_toConsumableArray","querySelectorAll","filter","el","closest","offsetParent","Events","_listeners","addQueue","removeQueue","current","Map","add","event","listener","push","removeAll","update","listeners","this","forEach","currentListeners","get","find","a","String","document","addEventListener","set","newListeners","removeEventListener","rootObj","element","body","domState","getElementState","inlineAttributes","Array","from","attributes","attributeObserver","screenReaderElement","methods","rules","updateElementState","callback","elementState","calculateSingle","input","findMatch","replaceWithPlainText","typeCount","b","c","parts","regex","type","matches","i","len","match","index","length","test","indexOf","substr","replace","join","sort","specificity","toString","specificityArray","compare","aSpecificity","bSpecificity","isArray","e","focus","option","HTMLElement","constructor","tabbableElements","currentIndex","findIndex","activeElement","finalIndex","currentTarget","blur","includes","toggleExpanded","parentSelector","childSelector","override","root","parentItem","childItem","expandValue","undefined","getAttribute","setAttribute","getExpanded","item","focusTrap","externalElements","parentElement","isTrapped","toggleFocusTrap","contains","exEls","tabindex","removeAttribute","trapFocus","updateFns","setAttr","name","value","isSame","isInline","startsWith","Object","keys","aria","attr","attrName","keyboard","keyboardEvent","utils","getUtilities","keyList","isValidKeyEvent","keyEvent","key","methodKey","mouse","click","enter","leave","addMouseEvent","methodKeys","eventStr","ruleSelector","reverse","screenReaderText","remove","span","createElement","style","textContent","insertBefore","firstChild","observerUtils","updateAttrsInState","attrMutations","mutation","modifiedAttr","target","attributeName","existingIdx","idx","arr","lastIdx","last","pop","swapAndPop","removeNonInlineAttrs","updateChildElAttrs","disconnect","_this","updateAll","setTimeout","observe","setAttrChangeCallback","attrChangeCallback","mutations","observer","_this2","ruleUtilities","setApplyRulesCallback","config","selectors","applyRulesCallback","addedNodes","some","node","rule","MutationObserver","watchAttributesForChanges","configType","childList","subtree"],"mappings":"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"}